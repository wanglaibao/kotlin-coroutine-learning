*   [structured concurrency] (https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/)
*   [structured-concurrency-resources] (https://trio.discourse.group/t/structured-concurrency-resources/21)
*   [Structured Concurrency] (http://250bpm.com/blog:71)
*   [Update on Structured Concurrency] (https://www.lesswrong.com/posts/bbDfSGd4daqPTRdK8/update-on-structured-concurrency)

### 协程概述

```
     Kotlinx-Coroutine 库的核心负责人Roman Elizarov将协程描述为轻量级的线程.

     线程是由系统调度的并且线程上下文的切换开销比较大,
     协程依赖于线程,一般运行于线程池中,但是协程挂起时不会阻塞线程的执行,
     协程是由开发者控制的,是用户态的线程,非常轻量级,一个线程中可以创建超过100万个协程.
     一般一个单机可以创建200万到500万左右的协程是没有什么压力的

     协程有助于我们简化异步编程: 协程通过将复杂性放入库来简化异步编程.
     程序的逻辑可以在协程中顺序地表达，而底层的协程库会为我们解决其异步性.
     协程库可以将用户代码的相关部分包装为回调,订阅相关事件,并且在不同线程【甚至不同机器】上调度执行,
     而代码则保持如同顺序执行一样简单.
```

### 协程核心概念和挂起函数

*   CoroutineScope

*   CoroutineContext

*   CoroutineDispatcher

    ```
        CoroutineDispatcher:协程调度器,决定协程在哪个线程或线程池中运行.
                            它可以指定协程运行于一个特定的线程,线程池或者不指定任何线程[这样协程就会运行于当前线程]


        协程调度器有四种类型分别为Dispatchers.Default,Dispatchers.IO,Dispatchers.Main和Dispatchers.Unconfined[不指定线程].

        launch函数定义中如果不指定CoroutineDispatcher或者没有其他的ContinuationInterceptor,
        默认的协程调度器就是Dispatchers.Default,Default是一个协程调度器,其指定的线程为CommonPool线程池,
        线程数量最小为2最大为CPU的处理器数相同.

    ```

*   Coroutine builders

    ```
        CoroutineScope.launch{}:

                CoroutineScope.launch{}是最常用的Coroutine builders,用来创建新的协程并且不阻塞当前线程,

                                        也可以指定协程调度器,例如在Android框架中常用的GlobalScope.launch(Dispatchers.Main){}

        CoroutineScope.async{}:

                CoroutineScope.async{}函数实现与launch{}函数一样的效果,创建一个新协程,唯一的区别是它有返回值.

                                     返回的是Deferred<T>类型; 获取返回值需要通过await{}函数,是个挂起函数,

                                     调用时会挂起当前协程直到async{}中代码执行完并返回某个值.


        runBlocking{}:

                runBlocking{}函数用于创建一个新的协程同时阻塞当前线程,直到协程结束.

                runBlocking{}函数主要是为main函数和测试设计的,在应用的各层逻辑中最好不要轻易使用.


        withContext{}:

            withContext{}函数不会创建新的协程,只是在指定协程上运行挂起代码块,并挂起该协程直至代码块运行完成.

    ```

*    Job & Deferred<T>
```
    Job任务封装了协程中需要执行的代码逻辑,Jo 可以取消协程的执行，它有六种状态:


    State	                            [isActive]	[isCompleted]	[isCancelled]

    New[optional initial state]	            false	    false	        false

    Active[default initial state]	        true	    false	        false

    Completing[optional transient state]	true	    false	        false

    Cancelling[optional transient state]	false	    false	        true

    Cancelled[final state]	                false	    true	        true

    Completed[final state]	                false	    true	        false


    Job任务完成时是没有返回值的,如果需要返回值的话,应该使用Deferred<T>,
    它是Job的子类:public interface Deferred<out T> : Job

```

* suspend function

```
    函数名前面有suspend修饰符标记的,表示挂起函数,挂起函数只能在协程中或其他挂起函数中调用.

    挂起函数能够以与普通函数相同的方式获取参数和返回值,但是调用挂起函数可能挂起协程[如果相关调用的结果已经可用,库可以决定继续进行而不挂起],

    挂起函数挂起协程时,不会阻塞协程所在的线程.

    挂起函数执行完成后会resume[恢复协程],后面的代码会继续执行.

    但是挂起函数只能在协程中或其他挂起函数中调用.

    事实上,要启动协程,至少要有一个挂起函数,它通常是一个挂起lambda表达式.

    所以suspend修饰符可以标记普通函数,扩展函数和lambda表达式以表示挂起的含义.
```

